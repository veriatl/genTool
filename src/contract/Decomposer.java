package contract;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.m2m.atl.common.OCL.*;

import org.eclipse.m2m.atl.emftvm.ExecEnv;

import Ocl.TypeInference;
import datastructure.Node;
import datastructure.ProveOption;
import datastructure.Tactic;
import metamodel.EMFLoader;
import transformation.Trace;


//TODO
// Control bv, forall a2 implies exists a2




public class Decomposer extends OperatorCallExp {

	static Map<String, ArrayList<String>> trace;
	
	static ArrayList<Node> tree = new ArrayList<Node>();
	
	//static OCLFactory make = OCLFactory.init();

	static String indent(int depth) {
		String rtn = "";
		for (int i = 0; i < depth; i++) {
			rtn += "\t";
		}
		return rtn;
	}

	static ArrayList<HashMap<EObject, String>> decompose(OclExpression expr, HashMap<EObject, String> Inferred, int depth, ProveOption op) {
		ArrayList<HashMap<EObject, String>> rtn;
		if (expr instanceof IteratorExp) {
			IteratorExp todo = (IteratorExp) expr;
			rtn = _decompose(todo, Inferred, depth, op);
		}else if(expr instanceof OperatorCallExp){
			OperatorCallExp todo = (OperatorCallExp) expr;
			rtn = _decompose(todo, Inferred, depth, op);
		}else{
			rtn = new ArrayList<HashMap<EObject, String>>();
		}
		
		return rtn;
	}

	static ArrayList<HashMap<EObject, String>> _decompose(IteratorExp expr, HashMap<EObject, String> Inferred, int depth, ProveOption op) {

		Iterator bv = expr.getIterators().get(0);
		OclExpression loopBody = expr.getBody();
		OclExpression loopSrc = expr.getSource();
		String bvType = TypeInference.infer(loopSrc);

		System.out.print(indent(depth));

		
		if (expr.getName().toLowerCase().equals("forall")) {		
			// rewrite: forall(bv, bv in col ==> body) <==> 
			for (String rule : trace.get(bvType)) {
				// infer construction
				HashMap<EObject, String> newInferred = new HashMap<EObject, String>(Inferred);
				newInferred.put(bv, "assumption, generated by "+rule);

				// add to the prove tree
				Node n = new Node(depth + 1, loopBody, expr, newInferred, ProveOption.EACH, Tactic.FORALL_INTRO_DECOMPOSE);
				tree.add(n);
				
				// decompose further
				decompose(loopBody, newInferred, depth + 1, ProveOption.EACH);

			}

		}

		return new ArrayList<HashMap<EObject, String>>();
		
		
	}
	
	static ArrayList<HashMap<EObject, String>> _decompose(OperatorCallExp expr, HashMap<EObject, String> Inferred, int depth, ProveOption op){
		
		ArrayList<HashMap<EObject, String>> rtn = new ArrayList<HashMap<EObject, String>>();
		
		if(expr.getOperationName().equals("implies")){
			
			OclExpression rhs = expr.getArguments().get(0);
			ArrayList<HashMap<EObject, String>> infersFromSource = decompose(expr.getSource(), Inferred, depth, op);
			HashMap<EObject, String> inferNextLv = new HashMap<EObject, String>(Inferred);
			
			if(infersFromSource.size() != 0){
				for(HashMap<EObject, String> inferFromSource : infersFromSource){	
					inferFromSource.put(expr.getSource(), "assumption");	
					inferNextLv.putAll(inferFromSource); //TODO optimization, check conflict inferred info
					
					
					Node n = new Node(depth + 1, rhs, expr, inferNextLv, op, Tactic.IMPLY_INTRO);
					tree.add(n);
					
					decompose(rhs, inferNextLv, depth + 1, op);
				}	
			}else{
				inferNextLv.put(expr.getSource(), "assumption");
				
				Node n = new Node(depth + 1, rhs, expr, inferNextLv, op, Tactic.IMPLY_INTRO);
				tree.add(n);
				
				decompose(rhs, inferNextLv, depth + 1, op);
			}
			
			rtn.add(inferNextLv);
			
			return rtn;
		}
		
		
		return rtn;
		
	}
	
	

	public static void main(String[] args) throws Exception {
		ExecEnv env = Trace.moduleLoader(args[0], args[1], args[2], args[3], args[4], args[5]);
		EPackage tarmm = EMFLoader.loadEcore(args[3]);
		trace = Trace.getTrace(tarmm, env);

		List<OclExpression> postconditions = ContractLoader.init("HSM2FSM/Source/ContractSRC/HSM2FSMContract.atl");

		for (OclExpression post : postconditions) {
			HashMap<EObject, String> emptyTrace = new HashMap<EObject, String>();
			Node root = new Node(0, post, null, emptyTrace, null, null);
			tree.add(root);
			decompose(post, emptyTrace, 0, ProveOption.EACH);	//TODO, default prove option
		}

	}
}
