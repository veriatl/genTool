module HSM2FSM;

create OUT : FSM from IN : HSM;



--POSTCONDITION FSM

--@post
helper context FSM!StateMachine def: unique_fsm_sm_names(): Boolean = -- different target state machines have different names
  FSM!StateMachine.allInstances()->forAll(s1,s2 | s1<>s2 implies s1.name<>s2.name);
  
--@post  
helper context FSM!AbstractState def: unique_fsm_state_names(): Boolean = -- states have unique names
  FSM!AbstractState.allInstances()->forAll(s1,s2 | s1<>s2 implies s1.name<>s2.name);	

--@post
helper context FSM!AbstractState def: fsm_state_multi_lower(): Boolean = -- a state does belong to at least one state machine
  FSM!AbstractState.allInstances()->forAll(s | not s.stateMachine.oclIsUndefined());

--@post
helper context FSM!AbstractState def: fsm_state_multi_upper(): Boolean = -- a state does belong to at most one state machine
  FSM!AbstractState.allInstances()->forAll(s | 
    FSM!StateMachine.allInstances()->forAll(sm1,sm2 | 
      s.stateMachine=sm1 and s.stateMachine=sm2 implies sm1=sm2));
    
--@post
helper context FSM!Transition def: fsm_transition_multi_lower(): Boolean = -- a transition does belong to at least one state machine
  FSM!Transition.allInstances()->forAll(t | not t.stateMachine.oclIsUndefined());

--@post
helper context FSM!Transition def: fsm_transition_multi_upper(): Boolean = -- a transition does belong to at most one state machine
  FSM!Transition.allInstances()->forAll(t | 
    FSM!StateMachine.allInstances()->forAll(sm1,sm2 | 
      t.stateMachine=sm1 and t.stateMachine=sm2 implies sm1=sm2))  ;  
    
--@post
helper context FSM!Transition def: fsm_transition_src_multi_lower(): Boolean = -- a transition has at least one source
  FSM!Transition.allInstances()->forAll(t | not t.source.oclIsUndefined());

--@post
helper context FSM!Transition def: fsm_transition_src_multi_upper(): Boolean = -- a transition has at most one source
  FSM!Transition.allInstances()->forAll(t | 
    FSM!AbstractState.allInstances()->forAll(s1,s2 | 
      t.source=s1 and t.source=s2 implies s1=s2));

--@post
helper context FSM!Transition def: fsm_transition_trg_multi_lower(): Boolean = -- a transition has at least one target
  FSM!Transition.allInstances()->forAll(t | not t.target.oclIsUndefined());

--@post
helper context FSM!Transition def: fsm_transition_trg_multi_upper(): Boolean = -- a transition has at most one target
  FSM!Transition.allInstances()->forAll(t | 
    FSM!AbstractState.allInstances()->forAll(s1,s2 | 
      t.target=s1 and t.target=s2 implies s1=s2));

--@post
helper context FSM!Transition def: fsm_transition_src_contain_sm(): Boolean = -- transition and source in the same state machine
  FSM!Transition.allInstances()->forAll(t |
    FSM!AbstractState.allInstances()->forAll(s |
      t.source=s implies HSM!StateMachine.allInstances()->forAll(sm1,sm2 | 
        t.stateMachine=sm1 and s.stateMachine=sm2 implies sm1=sm2)));

--@post
helper context FSM!Transition def: fsm_transition_trg_contain_sm(): Boolean = -- transition and target in the same state machine
  FSM!Transition.allInstances()->forAll(t |
    FSM!AbstractState.allInstances()->forAll(s |
      t.target=s implies HSM!StateMachine.allInstances()->forAll(sm1,sm2 | 
        t.stateMachine=sm1 and s.stateMachine=sm2 implies sm1=sm2)));

--@post
helper context FSM!Transition def: fsm_transition_contain_sm(): Boolean = -- source and target in the same state machine
  FSM!Transition.allInstances()->forAll(t |
    FSM!AbstractState.allInstances()->forAll(s1,s2 |
      t.source=s1 and t.target=s2 implies HSM!StateMachine.allInstances()->forAll(sm1,sm2 | 
        s1.stateMachine=sm1 and s2.stateMachine=sm2 implies sm1=sm2)));


