module HSM2FSM;

create OUT : FSM from IN : HSM;



--POSTCONDITION FSM

--@post
--helper context FSM!Transition def: fsm_transition_src_multi_lower(): Boolean = -- a transition has at least one source
--  FSM!Transition.allInstances()->forAll(t | t.source.oclIsUndefined());
  
--@post
--helper context FSM!Transition def: fsm_transition_trg_multi_lower(): Boolean = -- a transition has at least one target
--  FSM!Transition.allInstances()->forAll(t | t.target.oclIsUndefined());


--@post
helper context FSM!Transition def: fsm_transition_trg_multi_lower(): Boolean = -- a transition has at least one target[Not Deep]
  FSM!Transition.allInstances()->forAll(t |not t.source.oclIsUndefined());

--@post
--helper context FSM!StateMachine def: unique_fsm_sm_names(): Boolean = -- different target state machines have different names
-- FSM!StateMachine.allInstances()->forAll(s1 | 
--  	FSM!StateMachine.allInstances()->forAll(s2 | 
--  	  s1<>s2 implies s1.name<>s2.name));


--@post  
--helper context FSM!AbstractState def: unique_fsm_state_names(): Boolean = -- states have unique names
--  FSM!AbstractState.allInstances()->forAll(s1 |
--  	FSM!AbstractState.allInstances()->forAll(s2 |
--  	  s1<>s2 implies s1.name<>s2.name));	

--@post
--helper context FSM!AbstractState def: fsm_state_multi_lower(): Boolean = -- a state does belong to at least one state machine
--  FSM!AbstractState.allInstances()->forAll(s | s.stateMachine.oclIsUndefined());
    
--@post
--helper context FSM!Transition def: fsm_transition_multi_lower(): Boolean = -- a transition does belong to at least one state machine
--  FSM!Transition.allInstances()->forAll(t | t.stateMachine.oclIsUndefined());

--@post


--helper context FSM!Transition def: fsm_transition_src_multi_upper(): Boolean = -- a transition has at most one source [Not Deep]
--  FSM!Transition.allInstances()->forAll(t | 
--   FSM!AbstractState.allInstances()->forAll(s1 | 
--      FSM!AbstractState.allInstances()->forAll(s2 |
--       (t.source=s1 and t.source=s2) implies s1=s2)));